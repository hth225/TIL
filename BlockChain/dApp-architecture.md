# dApp 아키텍쳐에 대한 이해 (이더리움 기반)

## Idea
- 데이터를 중앙서버가 갖는것이 아닌, 각 노드들이 동일한 복제본을 보관하는 것
- 각 노드가 가진 데이터를 지속적으로 동기화 하여 일치시켜 나감으로써 데이터의 무결성을 유지

```
데이터는 다수의 어카운트로 구성되는데, 어카운트에는 두 가지 형태가 있음
- 사용자 어카운트(Private key에 의해 제어됨)
- 컨트랙트(코드에 의해 제어됨, 핵심적인 비즈니스 로직을 구성)
이들 어카운트들은 모두 상태(state) 정보를 가짐
```
> 솔리디티(Solidity)
> * 이더리움 컨트랙트 코드를 프로그래밍하는 상위 언어
> * EVM이라는 가상머신을 통해 수행, 결과에 의해 어카운트의 상태 변화

### 트랜잭션
- 위에서 언급한 상태 정보를 바꾸는 것
- 두 가지 어카운트 모두에서 발생시킬 수 있음
- 일정한 주기마다 블록이라는 그룹으로 묶여 다른노드들로 전파됨
- 각 블록에는 데이터의 위변조를 방지하기 위해 포함된 트랜잭션의 해시값과 이전 블록의 해시값을 포함하게 함

### 합의 알고리즘
- 네트워크에 참가하고 있는 모든 노드들은 각자 블록을 처리하고 결과가 동일함을 **합의(consensus)**함.
- 여러 솔루션이 있음
    - 현재 이더리움의 솔루션 = [Proof of Work 알고리즘](Doc/POW.md)
    - [Proof of stake 알고리즘](Doc/POS.md)
    - [PBFT(Practical Byzantine Fault Tolerance) 비잔틴 합의 알고리즘에 지분 개념을 더한 알고리즘]()
- 각 노드들의 합의를 통해서 블록체인의 무결성이 유지됨

## dApp 아키텍쳐의 장점
- 운영주체의 신뢰가 필요없거나 최소화
- 투명한 운영
- 보안 향상
- 이미 투자된 자원의 활용도 증가
- 글로벌 서비스 용이
- 소수기업의 서비스/이윤 독점화 해소

## 해결해야 할 과제
- 트랜잭션을 실행할 때 네트워크에 있는 모든 노드들이 이를 다 실행해야 함
- 복잡한 트랜잭션 또는 로직에 있어 많은 비용이 소모됨
- 현재는 단순한 키-밸류 형태에 불과함

> [출처](http://www.chaintalk.io/archive/lecture/43)